"use strict";(()=>{var __defProp=Object.defineProperty;var __defNormalProp=(obj,key,value)=>key in obj?__defProp(obj,key,{enumerable:true,configurable:true,writable:true,value}):obj[key]=value;var __publicField=(obj,key,value)=>{__defNormalProp(obj,typeof key!=="symbol"?key+"":key,value);return value};var getEntityCoords=entity=>{const[x,y,z]=GetEntityCoords(entity,true);return{x,y,z}};function degToRad(deg){if(typeof deg==="number"){return deg*Math.PI/180}return{x:deg.x*Math.PI/180,y:deg.y*Math.PI/180,z:deg.z*Math.PI/180}}var Logger=class{constructor(name){__publicField(this,"name");this.name=name}log(level,...args){console.log(`[${this.name}] (${level}) ${args.join(" ")}`)}info(...args){this.log("INFO",...args)}warn(...args){this.log("WARN",...args)}error(...args){this.log("ERROR",...args)}debug(...args){this.log("DEBUG",...args)}};var NUI_CALLBACK_NAME="request";var NuiComms=class{constructor(){this.handleRequest=async(data,cb)=>{const handler=this.handlers[data.action];if(!handler){cb({data:null,meta:{ok:false,message:`No requesthandler for ${data.action}`}});return}try{const result=await this.handlers[data.action](data.data);cb({data:result??null,meta:{ok:true}})}catch(e){cb({data:null,meta:{ok:false,message:e?.message??"Unknown error"}})}};this.logger=new Logger("NuiActions");this.handlers={};this.ready=false;this.awaitingReadyResolvers=[]}init(){RegisterNuiCallbackType(NUI_CALLBACK_NAME);on(`__cfx_nui:${NUI_CALLBACK_NAME}`,this.handleRequest);const readyProm=new Promise(res=>{this.register("ready",()=>{this.ready=true;this.awaitingReadyResolvers.forEach(res2=>res2());this.awaitingReadyResolvers=[];this.logger.info("Ready");res()})});return readyProm}send(action,data){if(!this.ready){const awaitingReadyPromise=new Promise(res=>{this.awaitingReadyResolvers.push(res)});awaitingReadyPromise.then(()=>{this.send(action,data)});return}SendNUIMessage({action,data})}register(name,cb){if(this.handlers[name]){this.logger.error(`Handler for "${String(name)}" already exists`);return}this.handlers[name]=cb}};var nuiComms=new NuiComms;var FAR_DISTANCE=50;var keyTickId=null;var allDoors=[];var doorStates=new Map;var initializeDoorStates=()=>{allDoors.forEach(door=>{if(!doorStates.has(door.id)){doorStates.set(door.id,false)}})};onNet("kbs_doorlock:initialize",doorConfigs=>{allDoors=doorConfigs.map(door=>({...door,position:door.position,rotation:door.rotation}));initializeDoorStates()});var Camera=class{constructor(){this.onFrame=()=>{const nearbyDoor=this.isNearAnyDoor();if(nearbyDoor===null){if(this.nerbyDoorLocation!==null){nuiComms.send("update",{camera:{position:this.getCameraPosition(),rotation:this.getCameraRotation()},nerbyDoorLocation:null,isOpened:false,rotation:{x:0,y:0,z:0}})}this.nerbyDoorLocation=null;this.currentDoorId=null;this.stopKeyListener();if(!this.isWithinFarDistance()){this.startFarModeLoop()}return}this.nerbyDoorLocation={x:nearbyDoor.x,y:nearbyDoor.y,z:nearbyDoor.z};this.currentDoorId=nearbyDoor.id;const newMetadata={fov:GetFinalRenderedCamFov(),near:GetFinalRenderedCamNearClip(),far:GetFinalRenderedCamFarClip()};const metaChanged=Object.entries(newMetadata).some(([k,v])=>this.metadata[k]!==v);const updateData={camera:{position:this.getCameraPosition(),rotation:this.getCameraRotation(),meta:metaChanged?newMetadata:void 0},nerbyDoorLocation:this.nerbyDoorLocation,isOpened:this.getCurrentDoorState(),rotation:allDoors.find(d=>d.id===this.currentDoorId)?.rotation||{x:0,y:0,z:0}};nuiComms.send("update",updateData);if(keyTickId===null){this.startKeyListener()}this.metadata=newMetadata};this.metadata={fov:0,near:0,far:0};this.thread=null;this.nerbyDoorLocation=null;this.currentDoorId=null;initializeDoorStates()}startThread(){if(this.thread)return;this.startFarModeLoop()}addDoor(doorConfig){if(!allDoors.find(d=>d.id===doorConfig.id)){allDoors.push(doorConfig);doorStates.set(doorConfig.id,false);console.log(`Added door ${doorConfig.id} to camera system`)}else{console.log(`Door ${doorConfig.id} already exists in camera system`)}}removeDoor(doorId){allDoors=allDoors.filter(d=>d.id!==doorId);doorStates.delete(doorId);console.log(`Removed door ${doorId} from camera system`)}getAllDoors(){return[...allDoors]}clearAllDoors(){allDoors=[];doorStates.clear()}setOpened(doorId,isOpened){doorStates.set(doorId,isOpened)}getDoorState(doorId){return doorStates.get(doorId)??false}getCurrentDoorState(){if(this.currentDoorId===null)return false;return this.getDoorState(this.currentDoorId)}getPlayerPosition(){const[x,y,z]=GetEntityCoords(PlayerPedId(),false);return{x,y,z}}calculateDistance(pos1,pos2){const dx=pos1.x-pos2.x;const dy=pos1.y-pos2.y;const dz=pos1.z-pos2.z;const distance=Math.sqrt(dx*dx+dy*dy+dz*dz);return distance}getEntityCenterPosition(entity){const[x,y,z]=GetEntityCoords(entity,false);const model=GetEntityModel(entity);const[minVector,maxVector]=GetModelDimensions(model);const[minX,minY,minZ]=minVector;const[maxX,maxY,maxZ]=maxVector;const centerOffsetX=(minX+maxX)/2;const centerOffsetY=(minY+maxY)/2;const centerOffsetZ=(minZ+maxZ)/2;const[rotX,rotY,rotZ]=GetEntityRotation(entity,2);const rotXRad=rotX*Math.PI/180;const rotYRad=rotY*Math.PI/180;const rotZRad=rotZ*Math.PI/180;const cosZ=Math.cos(rotZRad);const sinZ=Math.sin(rotZRad);const transformedOffsetX=centerOffsetX*cosZ-centerOffsetY*sinZ;const transformedOffsetY=centerOffsetX*sinZ+centerOffsetY*cosZ;const transformedOffsetZ=centerOffsetZ;return{x:x+transformedOffsetX,y:y+transformedOffsetY,z:z+transformedOffsetZ}}isNearAnyDoor(){const playerPos=this.getPlayerPosition();let closestDoor=null;let closestDistance=Infinity;for(const doorData of allDoors){const doorMaxDistance=doorData.maxDistance||3;let doorPosition=null;const doorEntity=findEntityByDoorId(doorData.id);if(doorEntity&&DoesEntityExist(doorEntity)){doorPosition=this.getEntityCenterPosition(doorEntity)}if(!doorPosition&&doorData.position&&(doorData.position.x!==0||doorData.position.y!==0||doorData.position.z!==0)){doorPosition=doorData.position}if(!doorPosition){console.warn(`Camera: Door ${doorData.id} has no valid position, skipping`);continue}const distance=this.calculateDistance(playerPos,doorPosition);if(distance<=doorMaxDistance&&distance<closestDistance){closestDistance=distance;closestDoor={id:doorData.id,x:doorPosition.x,y:doorPosition.y,z:doorPosition.z}}}if(closestDoor){return{id:closestDoor.id,x:closestDoor.x,y:closestDoor.y,z:closestDoor.z,closestDistance}}return null}isWithinFarDistance(){const playerPos=this.getPlayerPosition();for(const doorData of allDoors){const doorMaxDistance=doorData.maxDistance||3;const doorFarDistance=Math.max(doorMaxDistance*10,FAR_DISTANCE);let doorPosition;if(doorData.position&&(doorData.position.x!==0||doorData.position.y!==0||doorData.position.z!==0)){doorPosition=doorData.position}else{const doorEntity=findEntityByDoorId(doorData.id);if(doorEntity){doorPosition=this.getEntityCenterPosition(doorEntity)}else{console.warn(`Camera: Door ${doorData.id} has no valid position, skipping`);continue}}const distance=this.calculateDistance(playerPos,doorPosition);if(distance<=doorFarDistance){return true}}return false}startFarModeLoop(){if(this.thread){clearInterval(this.thread)}this.thread=setInterval(()=>{const currentPos=this.getPlayerPosition();if(allDoors.length===0){return}if(this.isWithinFarDistance()){this.startNearModeLoop()}},1e3)}startNearModeLoop(){if(this.thread){clearInterval(this.thread)}refreshEntityMappings();this.thread=setInterval(this.onFrame,4)}startKeyListener(){if(keyTickId!==null)return;keyTickId=setTick(()=>{if(this.isNearAnyDoor()===null){this.stopKeyListener();return}const keyPressed=IsControlJustPressed(0,51);if(keyPressed){this.toggleDoor()}})}stopKeyListener(){if(keyTickId!==null){clearTick(keyTickId);keyTickId=null}}async toggleDoor(){if(this.currentDoorId===null)return;await toggleDoorByDoorId(this.currentDoorId)}getCameraPosition(){const[x,y,z]=GetFinalRenderedCamCoord();return{x,y,z}}getCameraRotation(){const[x,y,z]=GetFinalRenderedCamRot(1);return degToRad({x,y,z})}};var camera=new Camera;var Vector3=class _Vector3{constructor(x,y,z){this.x=x;this.y=y;this.z=z;this.x=x??0;this.y=y??0;this.z=z??0}static create(v1){if(typeof v1==="number"){return new _Vector3(v1,v1,v1)}if(Array.isArray(v1)){return new _Vector3(v1[0],v1[1],v1[2])}return new _Vector3(v1.x,v1.y,v1.z)}static clone(v1){return _Vector3.create(v1)}static add(v1,v2){if(typeof v2==="number"){return new _Vector3(v1.x+v2,v1.y+v2,v1.z+v2)}return new _Vector3(v1.x+v2.x,v1.y+v2.y,v1.z+v2.z)}static subtract(v1,v2){return new _Vector3(v1.x-v2.x,v1.y-v2.y,v1.z-v2.z)}static multiply(v1,v2){if(typeof v2==="number"){return new _Vector3(v1.x*v2,v1.y*v2,v1.z*v2)}return new _Vector3(v1.x*v2.x,v1.y*v2.y,v1.z*v2.z)}static divide(v1,v2){if(typeof v2==="number"){return new _Vector3(v1.x/v2,v1.y/v2,v1.z/v2)}return new _Vector3(v1.x/v2.x,v1.y/v2.y,v1.z/v2.z)}static dotProduct(v1,v2){return v1.x*v2.x+v1.y*v2.y+v1.z*v2.z}static crossProduct(v1,v2){const x=v1.y*v2.z-v1.z*v2.y;const y=v1.z*v2.x-v1.x*v2.z;const z=v1.x*v2.y-v1.y*v2.x;return new _Vector3(x,y,z)}static normalize(v){return _Vector3.divide(v,v.Length)}static isSame(v1,v2){return v1.x===v2.x&&v1.y===v2.y&&v1.z===v2.z}clone(){return new _Vector3(this.x,this.y,this.z)}distanceSquared(v){const w=this.subtract(v);return _Vector3.dotProduct(w,w)}distance(v){return Math.sqrt(this.distanceSquared(v))}get normalize(){return _Vector3.normalize(this)}crossProduct(v){return _Vector3.crossProduct(this,v)}dotProduct(v){return _Vector3.dotProduct(this,v)}add(v){return _Vector3.add(this,v)}subtract(v){return _Vector3.subtract(this,v)}multiply(v){return _Vector3.multiply(this,v)}divide(v){return _Vector3.divide(this,v)}replace(v){this.x=v.x;this.y=v.y;this.z=v.z}get Length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}};var Raycast=class _Raycast{constructor(distance=25,flag=-1,ignore=PlayerPedId()){const cameraCoords=Vector3.create(GetGameplayCamCoord());const cameraRotation=Vector3.create(GetGameplayCamRot(0));const forwardVector=_Raycast.getForwardVector(cameraRotation);const forwardCoords=cameraCoords.add(forwardVector.multiply(distance));const handle=StartExpensiveSynchronousShapeTestLosProbe(cameraCoords.x,cameraCoords.y,cameraCoords.z,forwardCoords.x,forwardCoords.y,forwardCoords.z,flag,ignore,0);const[_,hit,[hitCoordX,hitCoordY,hitCoordZ],[surfaceNormalX,surfaceNormalY,surfaceNormalZ],entityHit]=GetShapeTestResult(handle);this._hit=!!hit;if(this._hit){this._coords={x:hitCoordX,y:hitCoordY,z:hitCoordZ};this._surfaceNormal={x:surfaceNormalX,y:surfaceNormalY,z:surfaceNormalZ};if(entityHit&&DoesEntityExist(entityHit)&&GetEntityType(entityHit)!==0){this._entity=entityHit}else{this._entity=null}}else{this._coords=null;this._surfaceNormal=null;this._entity=null}}get hit(){return this._hit}get entity(){return this._entity}get coords(){return this._coords}get surfaceNormal(){return this._surfaceNormal}static getForwardVector(rotation){const rotationRadians=rotation.multiply(Math.PI/180);return new Vector3(-Math.sin(rotationRadians.z)*Math.abs(Math.cos(rotationRadians.x)),Math.cos(rotationRadians.z)*Math.abs(Math.cos(rotationRadians.x)),Math.sin(rotationRadians.x))}getSurfaceRotation(){if(!this.surfaceNormal)throw new Error("No surface normal found");const upVector=new Vector3(0,1,0);const rotationAxis=upVector.crossProduct(this.surfaceNormal).normalize;const rotationAngle=Math.acos(upVector.dotProduct(this.surfaceNormal));const rotationVector=rotationAxis.multiply(rotationAngle);return rotationVector}};var headingToRotation=headingDegrees=>{const headingRadians=headingDegrees*Math.PI/180;return{x:0,y:-headingRadians+Math.PI,z:0}};var managedDoors=new Map;var entityToDoorId=new Map;var unloadedDoors=new Map;var findEntityByDoorId=doorId=>{for(const[entity,mappedDoorId]of entityToDoorId.entries()){if(mappedDoorId===doorId){if(DoesEntityExist(entity)){return entity}else{entityToDoorId.delete(entity)}}}const doorData=managedDoors.get(doorId);if(doorData){const entity=findDoorEntity(doorData);if(entity){entityToDoorId.set(entity,doorId);return entity}if(doorData.doorType==="double"&&doorData.entityId2&&doorData.x2&&doorData.y2&&doorData.z2){const secondDoorData={...doorData,entityId:doorData.entityId2,x:doorData.x2,y:doorData.y2,z:doorData.z2,heading:doorData.heading2||doorData.heading};const entity2=findDoorEntity(secondDoorData);if(entity2){entityToDoorId.set(entity2,doorId);return entity2}}}return null};setImmediate(async()=>{await nuiComms.init();camera.startThread();setTimeout(()=>{if(managedDoors.size===0){TriggerServerEvent("kbs_doorlock:requestDoorData")}},5e3);setInterval(()=>{if(unloadedDoors.size>0){checkUnloadedDoors()}},2e3)});var serverDoorToConfig=doorData=>{return{id:doorData.id,position:{x:doorData.x,y:doorData.y,z:doorData.z},rotation:headingToRotation(doorData.heading),maxDistance:doorData.maxDistance||2}};var getEntityCenterPosition=entity=>{const[x,y,z]=GetEntityCoords(entity,false);const model=GetEntityModel(entity);const[minVector,maxVector]=GetModelDimensions(model);const[minX,minY,minZ]=minVector;const[maxX,maxY,maxZ]=maxVector;const centerOffsetX=(minX+maxX)/2;const centerOffsetY=(minY+maxY)/2;const centerOffsetZ=(minZ+maxZ)/2;const[rotX,rotY,rotZ]=GetEntityRotation(entity,2);const rotXRad=rotX*Math.PI/180;const rotYRad=rotY*Math.PI/180;const rotZRad=rotZ*Math.PI/180;const cosZ=Math.cos(rotZRad);const sinZ=Math.sin(rotZRad);const transformedOffsetX=centerOffsetX*cosZ-centerOffsetY*sinZ;const transformedOffsetY=centerOffsetX*sinZ+centerOffsetY*cosZ;const transformedOffsetZ=centerOffsetZ;return{x:x+transformedOffsetX,y:y+transformedOffsetY,z:z+transformedOffsetZ}};var findDoorEntity=doorData=>{const parts=doorData.entityId.split("_");if(parts.length<4){console.error(`Invalid entity ID format: ${doorData.entityId}`);return null}const expectedModelHash=parseInt(parts[0]);const entities=GetGamePool("CObject");for(const entity of entities){if(GetEntityModel(entity)===expectedModelHash){const[x,y,z]=GetEntityCoords(entity,false);const distance=Math.sqrt(Math.pow(x-doorData.x,2)+Math.pow(y-doorData.y,2)+Math.pow(z-doorData.z,2));if(distance<(doorData.maxDistance||2)){return entity}}}return null};onNet("kbs_doorlock:receiveDoorData",doors=>{managedDoors.clear();entityToDoorId.clear();unloadedDoors.clear();camera.clearAllDoors();for(const doorData of doors){addDoorToClientSystem(doorData)}});onNet("kbs_doorlock:doorAdded",doorData=>{console.log(`New door added: ${doorData.id}`);addDoorToClientSystem(doorData)});onNet("kbs_doorlock:doorRemoved",doorId=>{console.log(`Door removed: ${doorId}`);removeDoorFromClientSystem(doorId)});onNet("kbs_doorlock:doorStateChanged",(doorId,isLocked)=>{const doorData=managedDoors.get(doorId);if(doorData){doorData.isLocked=isLocked;managedDoors.set(doorId,doorData);if(doorData.doorType==="double"){DoorSystemSetDoorState(doorId+"_1",isLocked?1:0,false,false);DoorSystemSetDoorState(doorId+"_2",isLocked?1:0,false,false)}else{DoorSystemSetDoorState(doorId,isLocked?1:0,false,false)}camera.setOpened(doorId,!isLocked);console.log(`Door ${doorId} is now ${isLocked?"LOCKED":"UNLOCKED"}`)}});onNet("kbs_doorlock:doorAddResult",(success,doorId)=>{if(success&&doorId){console.log(`Door ${doorId} added successfully`)}else{console.log("Failed to add door")}});onNet("kbs_doorlock:doorMaxDistanceUpdated",(doorId,maxDistance)=>{const doorData=managedDoors.get(doorId);if(doorData){doorData.maxDistance=maxDistance;managedDoors.set(doorId,doorData);if(doorData.doorType==="double"){DoorSystemSetAutomaticDistance(doorId+"_1",maxDistance,false,false);DoorSystemSetAutomaticDistance(doorId+"_2",maxDistance,false,false)}else{DoorSystemSetAutomaticDistance(doorId,maxDistance,false,false)}const updatedDoorConfig=serverDoorToConfig(doorData);camera.removeDoor(doorId);camera.addDoor(updatedDoorConfig);camera.setOpened(doorId,!doorData.isLocked);console.log(`Door ${doorId} max distance updated to ${maxDistance}m`)}});onNet("kbs_doorlock:doorOpeningSpeedUpdated",(doorId,openingSpeed)=>{const doorData=managedDoors.get(doorId);if(doorData){doorData.openingSpeed=openingSpeed;managedDoors.set(doorId,doorData);if(doorData.doorType==="double"){DoorSystemSetAutomaticRate(doorId+"_1",openingSpeed,false,false);DoorSystemSetAutomaticRate(doorId+"_2",openingSpeed,false,false)}else{DoorSystemSetAutomaticRate(doorId,openingSpeed,false,false)}console.log(`Door ${doorId} opening speed updated to ${openingSpeed}s`)}});onNet("kbs_doorlock:doorRemoveResult",success=>{if(success){console.log("Door removed successfully")}else{console.log("Failed to remove door")}});onNet("kbs_doorlock:doorToggled",(doorId,isLocked)=>{console.log(`Door ${doorId} toggled to ${isLocked?"LOCKED":"UNLOCKED"}`)});var addDoorToClientSystem=doorData=>{const playerPos=getEntityCoords(PlayerPedId());if(camera.calculateDistance(playerPos,{x:doorData.x,y:doorData.y,z:doorData.z})>50){console.log(`Door ${doorData.id} is too far from player, adding to unloaded doors`);unloadedDoors.set(doorData.id,doorData);return}unloadedDoors.delete(doorData.id);managedDoors.set(doorData.id,doorData);const entity=findDoorEntity(doorData);if(entity){entityToDoorId.set(entity,doorData.id)}else{console.warn(`Could not find entity for door ${doorData.id}`)}let entity2=null;if(doorData.doorType==="double"&&doorData.entityId2&&doorData.x2&&doorData.y2&&doorData.z2){const secondDoorData={...doorData,entityId:doorData.entityId2,x:doorData.x2,y:doorData.y2,z:doorData.z2,heading:doorData.heading2||doorData.heading};entity2=findDoorEntity(secondDoorData);if(entity2){entityToDoorId.set(entity2,doorData.id)}else{console.warn(`Could not find second entity for double door ${doorData.id}`)}}try{if(doorData.doorType==="double"&&entity2&&doorData.x2&&doorData.y2&&doorData.z2){const modelHash1=entity?GetEntityModel(entity):0;const modelHash2=GetEntityModel(entity2);AddDoorToSystem(doorData.id+"_1",modelHash1,doorData.x,doorData.y,doorData.z,false,false,false);AddDoorToSystem(doorData.id+"_2",modelHash2,doorData.x2,doorData.y2,doorData.z2,false,false,false);DoorSystemSetDoorState(doorData.id+"_1",doorData.isLocked?1:0,false,false);DoorSystemSetDoorState(doorData.id+"_2",doorData.isLocked?1:0,false,false);DoorSystemSetAutomaticDistance(doorData.id+"_1",doorData.maxDistance||2,false,false);DoorSystemSetAutomaticDistance(doorData.id+"_2",doorData.maxDistance||2,false,false);DoorSystemSetAutomaticRate(doorData.id+"_1",doorData.openingSpeed||1,false,false);DoorSystemSetAutomaticRate(doorData.id+"_2",doorData.openingSpeed||1,false,false)}else{const modelHash=entity?GetEntityModel(entity):0;AddDoorToSystem(doorData.id,modelHash,doorData.x,doorData.y,doorData.z,false,false,false);DoorSystemSetDoorState(doorData.id,doorData.isLocked?1:0,false,false);DoorSystemSetAutomaticDistance(doorData.id,doorData.maxDistance||2,false,false);DoorSystemSetAutomaticRate(doorData.id,doorData.openingSpeed||1,false,false)}}catch(error){console.error(`Failed to register door ${doorData.id} with FiveM system:`,error)}let doorConfig=serverDoorToConfig(doorData);if(entity){const entityCenter=getEntityCenterPosition(entity);doorConfig.position=entityCenter}camera.addDoor(doorConfig);camera.setOpened(doorData.id,!doorData.isLocked);console.log(`Successfully added door ${doorData.id}`)};var removeDoorFromClientSystem=doorId=>{const entitiesToRemove=[];for(const[entity,mappedDoorId]of entityToDoorId.entries()){if(mappedDoorId===doorId){entitiesToRemove.push(entity)}}entitiesToRemove.forEach(entity=>{entityToDoorId.delete(entity)});managedDoors.delete(doorId);unloadedDoors.delete(doorId);camera.removeDoor(doorId);console.log(`Removed door ${doorId}`)};var toggleDoorByDoorId=async doorId=>{TriggerServerEvent("kbs_doorlock:toggleDoor",doorId)};var refreshEntityMappings=()=>{let refreshCount=0;for(const[doorId,doorData]of managedDoors.entries()){const entity=findDoorEntity(doorData);if(entity){for(const[oldEntity,mappedDoorId]of entityToDoorId.entries()){if(mappedDoorId===doorId){entityToDoorId.delete(oldEntity)}}entityToDoorId.set(entity,doorId);refreshCount++}if(doorData.doorType==="double"&&doorData.entityId2&&doorData.x2&&doorData.y2&&doorData.z2){const secondDoorData={...doorData,entityId:doorData.entityId2,x:doorData.x2,y:doorData.y2,z:doorData.z2,heading:doorData.heading2||doorData.heading};const entity2=findDoorEntity(secondDoorData);if(entity2){entityToDoorId.set(entity2,doorId);refreshCount++}}}};var checkUnloadedDoors=()=>{const playerPos=getEntityCoords(PlayerPedId());const doorsToLoad=[];for(const[doorId,doorData]of unloadedDoors.entries()){const distance=camera.calculateDistance(playerPos,{x:doorData.x,y:doorData.y,z:doorData.z});if(distance<=50){doorsToLoad.push(doorId)}}for(const doorId of doorsToLoad){const doorData=unloadedDoors.get(doorId);if(doorData){console.log(`Player now close to door ${doorId}, loading it`);addDoorToClientSystem(doorData)}}};RegisterCommand("doorSystem",async()=>{TriggerServerEvent("kbs_doorlock:requestDoorData");const doorListLoaded=Array.from(managedDoors.values()).map(door=>({id:door.id,name:door.label||`Door ${door.id}`,type:door.doorType||"single",position:{x:door.x,y:door.y,z:door.z},isLocked:door.isLocked,maxDistance:door.maxDistance||2,openingSpeed:door.openingSpeed||1}));const doorlistUnloaded=Array.from(unloadedDoors.values()).map(door=>({id:door.id,name:door.label||`Door ${door.id}`,type:door.doorType||"single",position:{x:door.x,y:door.y,z:door.z},isLocked:door.isLocked,maxDistance:door.maxDistance||2,openingSpeed:door.openingSpeed||1}));const doorList=[...doorListLoaded,...doorlistUnloaded];SetNuiFocus(true,true);setTimeout(()=>{nuiComms.send("openMenu",{doors:doorList})},100)},false);RegisterNuiCallback("closeMenu",(data,cb)=>{SetNuiFocus(false,false);cb("ok")});RegisterNuiCallback("startDoorSelection",async(data,cb)=>{SetNuiFocus(false,false);const isDoubleDoor=data.type==="double";let selectedEntities=[];let entityData=[];const maxSelections=isDoubleDoor?2:1;let currentSelection=0;const performSelection=()=>new Promise(resolve=>{const thread=setInterval(()=>{const raycast=new Raycast;const plyCoords=getEntityCoords(PlayerPedId());if(raycast.hit&&raycast.entity&&raycast.coords){SetEntityDrawOutline(raycast.entity,true);SetEntityDrawOutlineColor(255,165,0,255);DrawLine(plyCoords.x,plyCoords.y,plyCoords.z,raycast.coords.x,raycast.coords.y,raycast.coords.z,255,165,0,255);DrawMarker(28,raycast.coords.x,raycast.coords.y,raycast.coords.z,0,0,0,0,0,0,.1,.1,.1,255,165,0,255,false,true,2,false,null,null,false);const entityModel=GetEntityModel(raycast.entity);const alreadySelected=selectedEntities.includes(raycast.entity);let displayText="";if(isDoubleDoor){displayText=`Entity: ${raycast.entity} | Model: ${entityModel}~n~${data.name} | ${data.type.toUpperCase()} DOOR (${currentSelection+1}/${maxSelections})~n~Distance: ${data.maxDistance}m`;if(alreadySelected){displayText+="~n~~r~Entity already selected!"}else{displayText+="~n~Press ENTER to select this door part"}}else{displayText=`Entity: ${raycast.entity} | Model: ${entityModel}~n~Name: ${data.name} | Type: ${data.type} | Distance: ${data.maxDistance}m~n~Press ENTER to select this door`}SetTextFont(4);SetTextScale(.4,.4);SetTextColour(255,255,255,255);SetTextOutline();BeginTextCommandDisplayText("STRING");AddTextComponentSubstringPlayerName(displayText);EndTextCommandDisplayText(.01,.5);if(IsControlJustPressed(0,18)&&!alreadySelected){SetEntityDrawOutline(raycast.entity,false);selectedEntities.push(raycast.entity);const entityCoords=getEntityCoords(raycast.entity);const entityHeading=GetEntityHeading(raycast.entity);const uniqueEntityId=`${entityModel}_${Math.round(entityCoords.x*1e3)}_${Math.round(entityCoords.y*1e3)}_${Math.round(entityCoords.z*1e3)}`;entityData.push({entity:raycast.entity,model:entityModel,coords:entityCoords,heading:entityHeading,uniqueId:uniqueEntityId});currentSelection++;if(currentSelection>=maxSelections){clearInterval(thread);resolve(true);return}}}else{let helpText="";if(isDoubleDoor){helpText=`Double Door Selection (${currentSelection}/${maxSelections})~n~Aim at door entities and press ENTER to select`}else{helpText="Aim at a door entity and press ENTER to select"}SetTextFont(4);SetTextScale(.4,.4);SetTextColour(255,255,255,255);SetTextOutline();BeginTextCommandDisplayText("STRING");AddTextComponentSubstringPlayerName(helpText);EndTextCommandDisplayText(.01,.5)}if(IsControlJustPressed(0,177)){selectedEntities.forEach(entity=>{SetEntityDrawOutline(entity,false)});if(raycast.entity){SetEntityDrawOutline(raycast.entity,false)}clearInterval(thread);resolve(false);return}},0)});const selectionResult=await performSelection();if(selectionResult&&entityData.length>0){let doorData={entityId:entityData[0].uniqueId,name:data.name,type:data.type,maxDistance:data.maxDistance,openingSpeed:data.openingSpeed,x:entityData[0].coords.x,y:entityData[0].coords.y,z:entityData[0].coords.z,heading:entityData[0].heading};if(isDoubleDoor&&entityData[1]){doorData.entityId2=entityData[1].uniqueId;doorData.x2=entityData[1].coords.x;doorData.y2=entityData[1].coords.y;doorData.z2=entityData[1].coords.z;doorData.heading2=entityData[1].heading}TriggerServerEvent("kbs_doorlock:addDoorWithDetails",doorData)}setTimeout(()=>{const doorList=Array.from(managedDoors.values()).map(door=>({id:door.id,name:door.label||`Door ${door.id}`,type:door.doorType||"single",position:{x:door.x,y:door.y,z:door.z},isLocked:door.isLocked,maxDistance:door.maxDistance||2,openingSpeed:door.openingSpeed||1}));SetNuiFocus(true,true);nuiComms.send("openMenu",{doors:doorList})},500);cb("ok")});RegisterNuiCallback("deleteDoor",(data,cb)=>{const doorData=managedDoors.get(data.doorId);if(doorData){if(doorData.doorType==="double"){const doorState1=DoorSystemGetDoorState(data.doorId+"_1");const doorState2=DoorSystemGetDoorState(data.doorId+"_2");if(doorState1===1){DoorSystemSetDoorState(data.doorId+"_1",0,false,false)}if(doorState2===1){DoorSystemSetDoorState(data.doorId+"_2",0,false,false)}}else{const doorState=DoorSystemGetDoorState(data.doorHash);if(doorState===1){DoorSystemSetDoorState(data.doorHash,0,false,false)}}}else{const doorState=DoorSystemGetDoorState(data.doorHash);if(doorState===1){DoorSystemSetDoorState(data.doorHash,0,false,false)}}TriggerServerEvent("kbs_doorlock:removeDoor",data.doorId);cb("ok")});RegisterNuiCallback("teleportToDoor",(data,cb)=>{const ped=PlayerPedId();SetEntityCoords(ped,data.position.x,data.position.y,data.position.z+1,false,false,false,false);cb("ok")});RegisterNuiCallback("updateDoorMaxDistance",(data,cb)=>{TriggerServerEvent("kbs_doorlock:updateDoorMaxDistance",data.doorId,data.maxDistance);cb("ok")});RegisterNuiCallback("updateDoorOpeningSpeed",(data,cb)=>{TriggerServerEvent("kbs_doorlock:updateDoorOpeningSpeed",data.doorId,data.openingSpeed);cb("ok")});})();
